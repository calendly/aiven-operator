//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright (c) 2022 Aiven, Helsinki, Finland. https://aiven.io/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthSecretReference) DeepCopyInto(out *AuthSecretReference) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthSecretReference.
func (in *AuthSecretReference) DeepCopy() *AuthSecretReference {
	if in == nil {
		return nil
	}
	out := new(AuthSecretReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Clickhouse) DeepCopyInto(out *Clickhouse) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Clickhouse.
func (in *Clickhouse) DeepCopy() *Clickhouse {
	if in == nil {
		return nil
	}
	out := new(Clickhouse)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Clickhouse) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseList) DeepCopyInto(out *ClickhouseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Clickhouse, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseList.
func (in *ClickhouseList) DeepCopy() *ClickhouseList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseSpec) DeepCopyInto(out *ClickhouseSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseSpec.
func (in *ClickhouseSpec) DeepCopy() *ClickhouseSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUser) DeepCopyInto(out *ClickhouseUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUser.
func (in *ClickhouseUser) DeepCopy() *ClickhouseUser {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserConfig) DeepCopyInto(out *ClickhouseUserConfig) {
	*out = *in
	if in.IpFilter != nil {
		in, out := &in.IpFilter, &out.IpFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserConfig.
func (in *ClickhouseUserConfig) DeepCopy() *ClickhouseUserConfig {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserList) DeepCopyInto(out *ClickhouseUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClickhouseUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserList.
func (in *ClickhouseUserList) DeepCopy() *ClickhouseUserList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserSpec) DeepCopyInto(out *ClickhouseUserSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserSpec.
func (in *ClickhouseUserSpec) DeepCopy() *ClickhouseUserSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserStatus) DeepCopyInto(out *ClickhouseUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserStatus.
func (in *ClickhouseUserStatus) DeepCopy() *ClickhouseUserStatus {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnInfoSecretTarget) DeepCopyInto(out *ConnInfoSecretTarget) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnInfoSecretTarget.
func (in *ConnInfoSecretTarget) DeepCopy() *ConnInfoSecretTarget {
	if in == nil {
		return nil
	}
	out := new(ConnInfoSecretTarget)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPool) DeepCopyInto(out *ConnectionPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPool.
func (in *ConnectionPool) DeepCopy() *ConnectionPool {
	if in == nil {
		return nil
	}
	out := new(ConnectionPool)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPool) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolList) DeepCopyInto(out *ConnectionPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ConnectionPool, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolList.
func (in *ConnectionPoolList) DeepCopy() *ConnectionPoolList {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPoolList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolSpec) DeepCopyInto(out *ConnectionPoolSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolSpec.
func (in *ConnectionPoolSpec) DeepCopy() *ConnectionPoolSpec {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolStatus) DeepCopyInto(out *ConnectionPoolStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolStatus.
func (in *ConnectionPoolStatus) DeepCopy() *ConnectionPoolStatus {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Database) DeepCopyInto(out *Database) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Database.
func (in *Database) DeepCopy() *Database {
	if in == nil {
		return nil
	}
	out := new(Database)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Database) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseList) DeepCopyInto(out *DatabaseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Database, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseList.
func (in *DatabaseList) DeepCopy() *DatabaseList {
	if in == nil {
		return nil
	}
	out := new(DatabaseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DatabaseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseSpec) DeepCopyInto(out *DatabaseSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseSpec.
func (in *DatabaseSpec) DeepCopy() *DatabaseSpec {
	if in == nil {
		return nil
	}
	out := new(DatabaseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseStatus) DeepCopyInto(out *DatabaseStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseStatus.
func (in *DatabaseStatus) DeepCopy() *DatabaseStatus {
	if in == nil {
		return nil
	}
	out := new(DatabaseStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkServiceKafkaConnectUserConfig) DeepCopyInto(out *KafkServiceKafkaConnectUserConfig) {
	*out = *in
	if in.ConsumerMaxPollRecords != nil {
		in, out := &in.ConsumerMaxPollRecords, &out.ConsumerMaxPollRecords
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushTimeoutMs != nil {
		in, out := &in.OffsetFlushTimeoutMs, &out.OffsetFlushTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerFetchMaxBytes != nil {
		in, out := &in.ConsumerFetchMaxBytes, &out.ConsumerFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollIntervalMs != nil {
		in, out := &in.ConsumerMaxPollIntervalMs, &out.ConsumerMaxPollIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushIntervalMs != nil {
		in, out := &in.OffsetFlushIntervalMs, &out.OffsetFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerMaxRequestSize != nil {
		in, out := &in.ProducerMaxRequestSize, &out.ProducerMaxRequestSize
		*out = new(int64)
		**out = **in
	}
	if in.SessionTimeoutMs != nil {
		in, out := &in.SessionTimeoutMs, &out.SessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPartitionFetchBytes != nil {
		in, out := &in.ConsumerMaxPartitionFetchBytes, &out.ConsumerMaxPartitionFetchBytes
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkServiceKafkaConnectUserConfig.
func (in *KafkServiceKafkaConnectUserConfig) DeepCopy() *KafkServiceKafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkServiceKafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafka) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACL) DeepCopyInto(out *KafkaACL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACL.
func (in *KafkaACL) DeepCopy() *KafkaACL {
	if in == nil {
		return nil
	}
	out := new(KafkaACL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLList) DeepCopyInto(out *KafkaACLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaACL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLList.
func (in *KafkaACLList) DeepCopy() *KafkaACLList {
	if in == nil {
		return nil
	}
	out := new(KafkaACLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLSpec) DeepCopyInto(out *KafkaACLSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLSpec.
func (in *KafkaACLSpec) DeepCopy() *KafkaACLSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaACLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLStatus) DeepCopyInto(out *KafkaACLStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLStatus.
func (in *KafkaACLStatus) DeepCopy() *KafkaACLStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaACLStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAuthenticationMethodsUserConfig) DeepCopyInto(out *KafkaAuthenticationMethodsUserConfig) {
	*out = *in
	if in.Certificate != nil {
		in, out := &in.Certificate, &out.Certificate
		*out = new(bool)
		**out = **in
	}
	if in.Sasl != nil {
		in, out := &in.Sasl, &out.Sasl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAuthenticationMethodsUserConfig.
func (in *KafkaAuthenticationMethodsUserConfig) DeepCopy() *KafkaAuthenticationMethodsUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaAuthenticationMethodsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnect) DeepCopyInto(out *KafkaConnect) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnect.
func (in *KafkaConnect) DeepCopy() *KafkaConnect {
	if in == nil {
		return nil
	}
	out := new(KafkaConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnect) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectList) DeepCopyInto(out *KafkaConnectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnect, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectList.
func (in *KafkaConnectList) DeepCopy() *KafkaConnectList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectPrivateAccessUserConfig) DeepCopyInto(out *KafkaConnectPrivateAccessUserConfig) {
	*out = *in
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectPrivateAccessUserConfig.
func (in *KafkaConnectPrivateAccessUserConfig) DeepCopy() *KafkaConnectPrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectPrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectPublicAccessUserConfig) DeepCopyInto(out *KafkaConnectPublicAccessUserConfig) {
	*out = *in
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectPublicAccessUserConfig.
func (in *KafkaConnectPublicAccessUserConfig) DeepCopy() *KafkaConnectPublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectPublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectSpec) DeepCopyInto(out *KafkaConnectSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectSpec.
func (in *KafkaConnectSpec) DeepCopy() *KafkaConnectSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectUserConfig) DeepCopyInto(out *KafkaConnectUserConfig) {
	*out = *in
	if in.ConsumerFetchMaxBytes != nil {
		in, out := &in.ConsumerFetchMaxBytes, &out.ConsumerFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPartitionFetchBytes != nil {
		in, out := &in.ConsumerMaxPartitionFetchBytes, &out.ConsumerMaxPartitionFetchBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollIntervalMs != nil {
		in, out := &in.ConsumerMaxPollIntervalMs, &out.ConsumerMaxPollIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollRecords != nil {
		in, out := &in.ConsumerMaxPollRecords, &out.ConsumerMaxPollRecords
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushIntervalMs != nil {
		in, out := &in.OffsetFlushIntervalMs, &out.OffsetFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerMaxRequestSize != nil {
		in, out := &in.ProducerMaxRequestSize, &out.ProducerMaxRequestSize
		*out = new(int64)
		**out = **in
	}
	if in.SessionTimeoutMs != nil {
		in, out := &in.SessionTimeoutMs, &out.SessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectUserConfig.
func (in *KafkaConnectUserConfig) DeepCopy() *KafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnector) DeepCopyInto(out *KafkaConnector) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnector.
func (in *KafkaConnector) DeepCopy() *KafkaConnector {
	if in == nil {
		return nil
	}
	out := new(KafkaConnector)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnector) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorList) DeepCopyInto(out *KafkaConnectorList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnector, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorList.
func (in *KafkaConnectorList) DeepCopy() *KafkaConnectorList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectorList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorPluginStatus) DeepCopyInto(out *KafkaConnectorPluginStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorPluginStatus.
func (in *KafkaConnectorPluginStatus) DeepCopy() *KafkaConnectorPluginStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorPluginStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorSpec) DeepCopyInto(out *KafkaConnectorSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorSpec.
func (in *KafkaConnectorSpec) DeepCopy() *KafkaConnectorSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorStatus) DeepCopyInto(out *KafkaConnectorStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.PluginStatus = in.PluginStatus
	out.TasksStatus = in.TasksStatus
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorStatus.
func (in *KafkaConnectorStatus) DeepCopy() *KafkaConnectorStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorTasksStatus) DeepCopyInto(out *KafkaConnectorTasksStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorTasksStatus.
func (in *KafkaConnectorTasksStatus) DeepCopy() *KafkaConnectorTasksStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorTasksStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaList) DeepCopyInto(out *KafkaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Kafka, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaList.
func (in *KafkaList) DeepCopy() *KafkaList {
	if in == nil {
		return nil
	}
	out := new(KafkaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPrivateAccessUserConfig) DeepCopyInto(out *KafkaPrivateAccessUserConfig) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPrivateAccessUserConfig.
func (in *KafkaPrivateAccessUserConfig) DeepCopy() *KafkaPrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaPrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPublicAccessUserConfig) DeepCopyInto(out *KafkaPublicAccessUserConfig) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.SchemaRegistry != nil {
		in, out := &in.SchemaRegistry, &out.SchemaRegistry
		*out = new(bool)
		**out = **in
	}
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = new(bool)
		**out = **in
	}
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.KafkaRest != nil {
		in, out := &in.KafkaRest, &out.KafkaRest
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPublicAccessUserConfig.
func (in *KafkaPublicAccessUserConfig) DeepCopy() *KafkaPublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaPublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaRestUserConfig) DeepCopyInto(out *KafkaRestUserConfig) {
	*out = *in
	if in.ConsumerRequestMaxBytes != nil {
		in, out := &in.ConsumerRequestMaxBytes, &out.ConsumerRequestMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerRequestTimeoutMs != nil {
		in, out := &in.ConsumerRequestTimeoutMs, &out.ConsumerRequestTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerLingerMs != nil {
		in, out := &in.ProducerLingerMs, &out.ProducerLingerMs
		*out = new(int64)
		**out = **in
	}
	if in.SimpleconsumerPoolSizeMax != nil {
		in, out := &in.SimpleconsumerPoolSizeMax, &out.SimpleconsumerPoolSizeMax
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerEnableAutoCommit != nil {
		in, out := &in.ConsumerEnableAutoCommit, &out.ConsumerEnableAutoCommit
		*out = new(bool)
		**out = **in
	}
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaRestUserConfig.
func (in *KafkaRestUserConfig) DeepCopy() *KafkaRestUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaRestUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchema) DeepCopyInto(out *KafkaSchema) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchema.
func (in *KafkaSchema) DeepCopy() *KafkaSchema {
	if in == nil {
		return nil
	}
	out := new(KafkaSchema)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchema) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaList) DeepCopyInto(out *KafkaSchemaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSchema, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaList.
func (in *KafkaSchemaList) DeepCopy() *KafkaSchemaList {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchemaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaRegistryConfig) DeepCopyInto(out *KafkaSchemaRegistryConfig) {
	*out = *in
	if in.LeaderEligibility != nil {
		in, out := &in.LeaderEligibility, &out.LeaderEligibility
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaRegistryConfig.
func (in *KafkaSchemaRegistryConfig) DeepCopy() *KafkaSchemaRegistryConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaRegistryConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaSpec) DeepCopyInto(out *KafkaSchemaSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaSpec.
func (in *KafkaSchemaSpec) DeepCopy() *KafkaSchemaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaStatus) DeepCopyInto(out *KafkaSchemaStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaStatus.
func (in *KafkaSchemaStatus) DeepCopy() *KafkaSchemaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSpec) DeepCopyInto(out *KafkaSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.Karapace != nil {
		in, out := &in.Karapace, &out.Karapace
		*out = new(bool)
		**out = **in
	}
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSpec.
func (in *KafkaSpec) DeepCopy() *KafkaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSubKafkaUserConfig) DeepCopyInto(out *KafkaSubKafkaUserConfig) {
	*out = *in
	if in.MessageMaxBytes != nil {
		in, out := &in.MessageMaxBytes, &out.MessageMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.DefaultReplicationFactor != nil {
		in, out := &in.DefaultReplicationFactor, &out.DefaultReplicationFactor
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMinCleanableRatio != nil {
		in, out := &in.LogCleanerMinCleanableRatio, &out.LogCleanerMinCleanableRatio
		*out = new(int64)
		**out = **in
	}
	if in.LogIndexIntervalBytes != nil {
		in, out := &in.LogIndexIntervalBytes, &out.LogIndexIntervalBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogSegmentDeleteDelayMs != nil {
		in, out := &in.LogSegmentDeleteDelayMs, &out.LogSegmentDeleteDelayMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxIncrementalFetchSessionCacheSlots != nil {
		in, out := &in.MaxIncrementalFetchSessionCacheSlots, &out.MaxIncrementalFetchSessionCacheSlots
		*out = new(int64)
		**out = **in
	}
	if in.SocketRequestMaxBytes != nil {
		in, out := &in.SocketRequestMaxBytes, &out.SocketRequestMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerDeleteRetentionMs != nil {
		in, out := &in.LogCleanerDeleteRetentionMs, &out.LogCleanerDeleteRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.LogIndexSizeMaxBytes != nil {
		in, out := &in.LogIndexSizeMaxBytes, &out.LogIndexSizeMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogRollJitterMs != nil {
		in, out := &in.LogRollJitterMs, &out.LogRollJitterMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxConnectionsPerIP != nil {
		in, out := &in.MaxConnectionsPerIP, &out.MaxConnectionsPerIP
		*out = new(int64)
		**out = **in
	}
	if in.ReplicaFetchResponseMaxBytes != nil {
		in, out := &in.ReplicaFetchResponseMaxBytes, &out.ReplicaFetchResponseMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.AutoCreateTopicsEnable != nil {
		in, out := &in.AutoCreateTopicsEnable, &out.AutoCreateTopicsEnable
		*out = new(bool)
		**out = **in
	}
	if in.LogFlushIntervalMs != nil {
		in, out := &in.LogFlushIntervalMs, &out.LogFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.LogMessageDownconversionEnable != nil {
		in, out := &in.LogMessageDownconversionEnable, &out.LogMessageDownconversionEnable
		*out = new(bool)
		**out = **in
	}
	if in.LogRollMs != nil {
		in, out := &in.LogRollMs, &out.LogRollMs
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMinCompactionLagMs != nil {
		in, out := &in.LogCleanerMinCompactionLagMs, &out.LogCleanerMinCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.LogMessageTimestampDifferenceMaxMs != nil {
		in, out := &in.LogMessageTimestampDifferenceMaxMs, &out.LogMessageTimestampDifferenceMaxMs
		*out = new(int64)
		**out = **in
	}
	if in.LogRetentionMs != nil {
		in, out := &in.LogRetentionMs, &out.LogRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.GroupMinSessionTimeoutMs != nil {
		in, out := &in.GroupMinSessionTimeoutMs, &out.GroupMinSessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.LogSegmentBytes != nil {
		in, out := &in.LogSegmentBytes, &out.LogSegmentBytes
		*out = new(int64)
		**out = **in
	}
	if in.GroupMaxSessionTimeoutMs != nil {
		in, out := &in.GroupMaxSessionTimeoutMs, &out.GroupMaxSessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.LogFlushIntervalMessages != nil {
		in, out := &in.LogFlushIntervalMessages, &out.LogFlushIntervalMessages
		*out = new(int64)
		**out = **in
	}
	if in.LogPreallocate != nil {
		in, out := &in.LogPreallocate, &out.LogPreallocate
		*out = new(bool)
		**out = **in
	}
	if in.LogRetentionBytes != nil {
		in, out := &in.LogRetentionBytes, &out.LogRetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMaxCompactionLagMs != nil {
		in, out := &in.LogCleanerMaxCompactionLagMs, &out.LogCleanerMaxCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.LogRetentionHours != nil {
		in, out := &in.LogRetentionHours, &out.LogRetentionHours
		*out = new(int64)
		**out = **in
	}
	if in.MinInsyncReplicas != nil {
		in, out := &in.MinInsyncReplicas, &out.MinInsyncReplicas
		*out = new(int64)
		**out = **in
	}
	if in.NumPartitions != nil {
		in, out := &in.NumPartitions, &out.NumPartitions
		*out = new(int64)
		**out = **in
	}
	if in.OffsetsRetentionMinutes != nil {
		in, out := &in.OffsetsRetentionMinutes, &out.OffsetsRetentionMinutes
		*out = new(int64)
		**out = **in
	}
	if in.ConnectionsMaxIdleMs != nil {
		in, out := &in.ConnectionsMaxIdleMs, &out.ConnectionsMaxIdleMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerPurgatoryPurgeIntervalRequests != nil {
		in, out := &in.ProducerPurgatoryPurgeIntervalRequests, &out.ProducerPurgatoryPurgeIntervalRequests
		*out = new(int64)
		**out = **in
	}
	if in.ReplicaFetchMaxBytes != nil {
		in, out := &in.ReplicaFetchMaxBytes, &out.ReplicaFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSubKafkaUserConfig.
func (in *KafkaSubKafkaUserConfig) DeepCopy() *KafkaSubKafkaUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaSubKafkaUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopic) DeepCopyInto(out *KafkaTopic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopic.
func (in *KafkaTopic) DeepCopy() *KafkaTopic {
	if in == nil {
		return nil
	}
	out := new(KafkaTopic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicConfig) DeepCopyInto(out *KafkaTopicConfig) {
	*out = *in
	if in.DeleteRetentionMs != nil {
		in, out := &in.DeleteRetentionMs, &out.DeleteRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.FileDeleteDelayMs != nil {
		in, out := &in.FileDeleteDelayMs, &out.FileDeleteDelayMs
		*out = new(int64)
		**out = **in
	}
	if in.FlushMessages != nil {
		in, out := &in.FlushMessages, &out.FlushMessages
		*out = new(int64)
		**out = **in
	}
	if in.FlushMs != nil {
		in, out := &in.FlushMs, &out.FlushMs
		*out = new(int64)
		**out = **in
	}
	if in.IndexIntervalBytes != nil {
		in, out := &in.IndexIntervalBytes, &out.IndexIntervalBytes
		*out = new(int64)
		**out = **in
	}
	if in.MaxCompactionLagMs != nil {
		in, out := &in.MaxCompactionLagMs, &out.MaxCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxMessageBytes != nil {
		in, out := &in.MaxMessageBytes, &out.MaxMessageBytes
		*out = new(int64)
		**out = **in
	}
	if in.MessageDownconversionEnable != nil {
		in, out := &in.MessageDownconversionEnable, &out.MessageDownconversionEnable
		*out = new(bool)
		**out = **in
	}
	if in.MessageTimestampDifferenceMaxMs != nil {
		in, out := &in.MessageTimestampDifferenceMaxMs, &out.MessageTimestampDifferenceMaxMs
		*out = new(int64)
		**out = **in
	}
	if in.MinCompactionLagMs != nil {
		in, out := &in.MinCompactionLagMs, &out.MinCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MinInsyncReplicas != nil {
		in, out := &in.MinInsyncReplicas, &out.MinInsyncReplicas
		*out = new(int64)
		**out = **in
	}
	if in.Preallocate != nil {
		in, out := &in.Preallocate, &out.Preallocate
		*out = new(bool)
		**out = **in
	}
	if in.RetentionBytes != nil {
		in, out := &in.RetentionBytes, &out.RetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.RetentionMs != nil {
		in, out := &in.RetentionMs, &out.RetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentBytes != nil {
		in, out := &in.SegmentBytes, &out.SegmentBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentIndexBytes != nil {
		in, out := &in.SegmentIndexBytes, &out.SegmentIndexBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentJitterMs != nil {
		in, out := &in.SegmentJitterMs, &out.SegmentJitterMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentMs != nil {
		in, out := &in.SegmentMs, &out.SegmentMs
		*out = new(int64)
		**out = **in
	}
	if in.UncleanLeaderElectionEnable != nil {
		in, out := &in.UncleanLeaderElectionEnable, &out.UncleanLeaderElectionEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicConfig.
func (in *KafkaTopicConfig) DeepCopy() *KafkaTopicConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicList) DeepCopyInto(out *KafkaTopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaTopic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicList.
func (in *KafkaTopicList) DeepCopy() *KafkaTopicList {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicSpec) DeepCopyInto(out *KafkaTopicSpec) {
	*out = *in
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]KafkaTopicTag, len(*in))
		copy(*out, *in)
	}
	in.Config.DeepCopyInto(&out.Config)
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicSpec.
func (in *KafkaTopicSpec) DeepCopy() *KafkaTopicSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicStatus) DeepCopyInto(out *KafkaTopicStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicStatus.
func (in *KafkaTopicStatus) DeepCopy() *KafkaTopicStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicTag) DeepCopyInto(out *KafkaTopicTag) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicTag.
func (in *KafkaTopicTag) DeepCopy() *KafkaTopicTag {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicTag)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserConfig) DeepCopyInto(out *KafkaUserConfig) {
	*out = *in
	if in.SchemaRegistry != nil {
		in, out := &in.SchemaRegistry, &out.SchemaRegistry
		*out = new(bool)
		**out = **in
	}
	in.Kafka.DeepCopyInto(&out.Kafka)
	in.KafkaConnectConfig.DeepCopyInto(&out.KafkaConnectConfig)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.SchemaRegistryConfig.DeepCopyInto(&out.SchemaRegistryConfig)
	if in.IPFilter != nil {
		in, out := &in.IPFilter, &out.IPFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.KafkaAuthenticationMethods.DeepCopyInto(&out.KafkaAuthenticationMethods)
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.KafkaRest != nil {
		in, out := &in.KafkaRest, &out.KafkaRest
		*out = new(bool)
		**out = **in
	}
	in.KafkaRestConfig.DeepCopyInto(&out.KafkaRestConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserConfig.
func (in *KafkaUserConfig) DeepCopy() *KafkaUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MigrationUserConfig) DeepCopyInto(out *MigrationUserConfig) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.Ssl != nil {
		in, out := &in.Ssl, &out.Ssl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MigrationUserConfig.
func (in *MigrationUserConfig) DeepCopy() *MigrationUserConfig {
	if in == nil {
		return nil
	}
	out := new(MigrationUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearch) DeepCopyInto(out *OpenSearch) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearch.
func (in *OpenSearch) DeepCopy() *OpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearch) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchIndexPatterns) DeepCopyInto(out *OpenSearchIndexPatterns) {
	*out = *in
	if in.MaxIndexCount != nil {
		in, out := &in.MaxIndexCount, &out.MaxIndexCount
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchIndexPatterns.
func (in *OpenSearchIndexPatterns) DeepCopy() *OpenSearchIndexPatterns {
	if in == nil {
		return nil
	}
	out := new(OpenSearchIndexPatterns)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchIndexTemplate) DeepCopyInto(out *OpenSearchIndexTemplate) {
	*out = *in
	if in.NumberOfReplicas != nil {
		in, out := &in.NumberOfReplicas, &out.NumberOfReplicas
		*out = new(int64)
		**out = **in
	}
	if in.NumberOfShards != nil {
		in, out := &in.NumberOfShards, &out.NumberOfShards
		*out = new(int64)
		**out = **in
	}
	if in.MappingNestedObjectsLimit != nil {
		in, out := &in.MappingNestedObjectsLimit, &out.MappingNestedObjectsLimit
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchIndexTemplate.
func (in *OpenSearchIndexTemplate) DeepCopy() *OpenSearchIndexTemplate {
	if in == nil {
		return nil
	}
	out := new(OpenSearchIndexTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchList) DeepCopyInto(out *OpenSearchList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpenSearch, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchList.
func (in *OpenSearchList) DeepCopy() *OpenSearchList {
	if in == nil {
		return nil
	}
	out := new(OpenSearchList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearchList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPrivateAccess) DeepCopyInto(out *OpenSearchPrivateAccess) {
	*out = *in
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPrivateAccess.
func (in *OpenSearchPrivateAccess) DeepCopy() *OpenSearchPrivateAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPrivateAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPrivatelinkAccess) DeepCopyInto(out *OpenSearchPrivatelinkAccess) {
	*out = *in
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPrivatelinkAccess.
func (in *OpenSearchPrivatelinkAccess) DeepCopy() *OpenSearchPrivatelinkAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPrivatelinkAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPublicAccess) DeepCopyInto(out *OpenSearchPublicAccess) {
	*out = *in
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPublicAccess.
func (in *OpenSearchPublicAccess) DeepCopy() *OpenSearchPublicAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPublicAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchSpec) DeepCopyInto(out *OpenSearchSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchSpec.
func (in *OpenSearchSpec) DeepCopy() *OpenSearchSpec {
	if in == nil {
		return nil
	}
	out := new(OpenSearchSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchUserConfig) DeepCopyInto(out *OpenSearchUserConfig) {
	*out = *in
	in.OpensearchDashboards.DeepCopyInto(&out.OpensearchDashboards)
	in.PrivatelinkAccess.DeepCopyInto(&out.PrivatelinkAccess)
	if in.StaticIps != nil {
		in, out := &in.StaticIps, &out.StaticIps
		*out = new(bool)
		**out = **in
	}
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	if in.IndexPatterns != nil {
		in, out := &in.IndexPatterns, &out.IndexPatterns
		*out = make([]OpenSearchIndexPatterns, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.IpFilter != nil {
		in, out := &in.IpFilter, &out.IpFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.IndexTemplate.DeepCopyInto(&out.IndexTemplate)
	in.Opensearch.DeepCopyInto(&out.Opensearch)
	if in.MaxIndexCount != nil {
		in, out := &in.MaxIndexCount, &out.MaxIndexCount
		*out = new(int64)
		**out = **in
	}
	if in.DisableReplicationFactorAdjustment != nil {
		in, out := &in.DisableReplicationFactorAdjustment, &out.DisableReplicationFactorAdjustment
		*out = new(bool)
		**out = **in
	}
	if in.KeepIndexRefreshInterval != nil {
		in, out := &in.KeepIndexRefreshInterval, &out.KeepIndexRefreshInterval
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchUserConfig.
func (in *OpenSearchUserConfig) DeepCopy() *OpenSearchUserConfig {
	if in == nil {
		return nil
	}
	out := new(OpenSearchUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchUserConfigOpenSearch) DeepCopyInto(out *OpenSearchUserConfigOpenSearch) {
	*out = *in
	if in.ThreadPoolAnalyzeQueueSize != nil {
		in, out := &in.ThreadPoolAnalyzeQueueSize, &out.ThreadPoolAnalyzeQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolAnalyzeSize != nil {
		in, out := &in.ThreadPoolAnalyzeSize, &out.ThreadPoolAnalyzeSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolForceMergeSize != nil {
		in, out := &in.ThreadPoolForceMergeSize, &out.ThreadPoolForceMergeSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolGetSize != nil {
		in, out := &in.ThreadPoolGetSize, &out.ThreadPoolGetSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchThrottledQueueSize != nil {
		in, out := &in.ThreadPoolSearchThrottledQueueSize, &out.ThreadPoolSearchThrottledQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolWriteQueueSize != nil {
		in, out := &in.ThreadPoolWriteQueueSize, &out.ThreadPoolWriteQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ReindexRemoteWhitelist != nil {
		in, out := &in.ReindexRemoteWhitelist, &out.ReindexRemoteWhitelist
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IndicesFielddataCacheSize != nil {
		in, out := &in.IndicesFielddataCacheSize, &out.IndicesFielddataCacheSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesQueryBoolMaxClauseCount != nil {
		in, out := &in.IndicesQueryBoolMaxClauseCount, &out.IndicesQueryBoolMaxClauseCount
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolGetQueueSize != nil {
		in, out := &in.ThreadPoolGetQueueSize, &out.ThreadPoolGetQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolIndexSize != nil {
		in, out := &in.ThreadPoolIndexSize, &out.ThreadPoolIndexSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchQueueSize != nil {
		in, out := &in.ThreadPoolSearchQueueSize, &out.ThreadPoolSearchQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolWriteSize != nil {
		in, out := &in.ThreadPoolWriteSize, &out.ThreadPoolWriteSize
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxHeaderSize != nil {
		in, out := &in.HttpMaxHeaderSize, &out.HttpMaxHeaderSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesMemoryIndexBufferSize != nil {
		in, out := &in.IndicesMemoryIndexBufferSize, &out.IndicesMemoryIndexBufferSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesQueriesCacheSize != nil {
		in, out := &in.IndicesQueriesCacheSize, &out.IndicesQueriesCacheSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchSize != nil {
		in, out := &in.ThreadPoolSearchSize, &out.ThreadPoolSearchSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchThrottledSize != nil {
		in, out := &in.ThreadPoolSearchThrottledSize, &out.ThreadPoolSearchThrottledSize
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxInitialLineLength != nil {
		in, out := &in.HttpMaxInitialLineLength, &out.HttpMaxInitialLineLength
		*out = new(int64)
		**out = **in
	}
	if in.ActionDestructiveRequiresName != nil {
		in, out := &in.ActionDestructiveRequiresName, &out.ActionDestructiveRequiresName
		*out = new(bool)
		**out = **in
	}
	if in.ClusterMaxShardsPerNode != nil {
		in, out := &in.ClusterMaxShardsPerNode, &out.ClusterMaxShardsPerNode
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxContentLength != nil {
		in, out := &in.HttpMaxContentLength, &out.HttpMaxContentLength
		*out = new(int64)
		**out = **in
	}
	if in.SearchMaxBuckets != nil {
		in, out := &in.SearchMaxBuckets, &out.SearchMaxBuckets
		*out = new(int64)
		**out = **in
	}
	if in.ActionAutoCreateIndexEnabled != nil {
		in, out := &in.ActionAutoCreateIndexEnabled, &out.ActionAutoCreateIndexEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchUserConfigOpenSearch.
func (in *OpenSearchUserConfigOpenSearch) DeepCopy() *OpenSearchUserConfigOpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearchUserConfigOpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpensearchDashboards) DeepCopyInto(out *OpensearchDashboards) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.MaxOldSpaceSize != nil {
		in, out := &in.MaxOldSpaceSize, &out.MaxOldSpaceSize
		*out = new(int64)
		**out = **in
	}
	if in.OpensearchRequestTimeout != nil {
		in, out := &in.OpensearchRequestTimeout, &out.OpensearchRequestTimeout
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpensearchDashboards.
func (in *OpensearchDashboards) DeepCopy() *OpensearchDashboards {
	if in == nil {
		return nil
	}
	out := new(OpensearchDashboards)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgLookoutUserConfig) DeepCopyInto(out *PgLookoutUserConfig) {
	*out = *in
	if in.MaxFailoverReplicationTimeLag != nil {
		in, out := &in.MaxFailoverReplicationTimeLag, &out.MaxFailoverReplicationTimeLag
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgLookoutUserConfig.
func (in *PgLookoutUserConfig) DeepCopy() *PgLookoutUserConfig {
	if in == nil {
		return nil
	}
	out := new(PgLookoutUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgbouncerUserConfig) DeepCopyInto(out *PgbouncerUserConfig) {
	*out = *in
	if in.IgnoreStartupParameters != nil {
		in, out := &in.IgnoreStartupParameters, &out.IgnoreStartupParameters
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ServerResetQueryAlways != nil {
		in, out := &in.ServerResetQueryAlways, &out.ServerResetQueryAlways
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgbouncerUserConfig.
func (in *PgbouncerUserConfig) DeepCopy() *PgbouncerUserConfig {
	if in == nil {
		return nil
	}
	out := new(PgbouncerUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQL) DeepCopyInto(out *PostgreSQL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQL.
func (in *PostgreSQL) DeepCopy() *PostgreSQL {
	if in == nil {
		return nil
	}
	out := new(PostgreSQL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLList) DeepCopyInto(out *PostgreSQLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PostgreSQL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLList.
func (in *PostgreSQLList) DeepCopy() *PostgreSQLList {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLSpec) DeepCopyInto(out *PostgreSQLSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLSpec.
func (in *PostgreSQLSpec) DeepCopy() *PostgreSQLSpec {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLSubUserConfig) DeepCopyInto(out *PostgreSQLSubUserConfig) {
	*out = *in
	if in.LogMinDurationStatement != nil {
		in, out := &in.LogMinDurationStatement, &out.LogMinDurationStatement
		*out = new(int64)
		**out = **in
	}
	if in.MaxReplicationSlots != nil {
		in, out := &in.MaxReplicationSlots, &out.MaxReplicationSlots
		*out = new(int64)
		**out = **in
	}
	if in.MaxStandbyStreamingDelay != nil {
		in, out := &in.MaxStandbyStreamingDelay, &out.MaxStandbyStreamingDelay
		*out = new(int64)
		**out = **in
	}
	if in.PgPartmanBgwInterval != nil {
		in, out := &in.PgPartmanBgwInterval, &out.PgPartmanBgwInterval
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumThreshold != nil {
		in, out := &in.AutovacuumVacuumThreshold, &out.AutovacuumVacuumThreshold
		*out = new(int64)
		**out = **in
	}
	if in.Jit != nil {
		in, out := &in.Jit, &out.Jit
		*out = new(bool)
		**out = **in
	}
	if in.MaxPreparedTransactions != nil {
		in, out := &in.MaxPreparedTransactions, &out.MaxPreparedTransactions
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumFreezeMaxAge != nil {
		in, out := &in.AutovacuumFreezeMaxAge, &out.AutovacuumFreezeMaxAge
		*out = new(int64)
		**out = **in
	}
	if in.IdleInTransactionSessionTimeout != nil {
		in, out := &in.IdleInTransactionSessionTimeout, &out.IdleInTransactionSessionTimeout
		*out = new(int64)
		**out = **in
	}
	if in.WalSenderTimeout != nil {
		in, out := &in.WalSenderTimeout, &out.WalSenderTimeout
		*out = new(int64)
		**out = **in
	}
	if in.MaxPredLocksPerTransaction != nil {
		in, out := &in.MaxPredLocksPerTransaction, &out.MaxPredLocksPerTransaction
		*out = new(int64)
		**out = **in
	}
	if in.MaxWalSenders != nil {
		in, out := &in.MaxWalSenders, &out.MaxWalSenders
		*out = new(int64)
		**out = **in
	}
	if in.TrackActivityQuerySize != nil {
		in, out := &in.TrackActivityQuerySize, &out.TrackActivityQuerySize
		*out = new(int64)
		**out = **in
	}
	if in.MaxFilesPerProcess != nil {
		in, out := &in.MaxFilesPerProcess, &out.MaxFilesPerProcess
		*out = new(int64)
		**out = **in
	}
	if in.MaxParallelWorkersPerGather != nil {
		in, out := &in.MaxParallelWorkersPerGather, &out.MaxParallelWorkersPerGather
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumScaleFactor != nil {
		in, out := &in.AutovacuumVacuumScaleFactor, &out.AutovacuumVacuumScaleFactor
		*out = new(int64)
		**out = **in
	}
	if in.LogAutovacuumMinDuration != nil {
		in, out := &in.LogAutovacuumMinDuration, &out.LogAutovacuumMinDuration
		*out = new(int64)
		**out = **in
	}
	if in.MaxLocksPerTransaction != nil {
		in, out := &in.MaxLocksPerTransaction, &out.MaxLocksPerTransaction
		*out = new(int64)
		**out = **in
	}
	if in.MaxStackDepth != nil {
		in, out := &in.MaxStackDepth, &out.MaxStackDepth
		*out = new(int64)
		**out = **in
	}
	if in.MaxWorkerProcesses != nil {
		in, out := &in.MaxWorkerProcesses, &out.MaxWorkerProcesses
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumAnalyzeScaleFactor != nil {
		in, out := &in.AutovacuumAnalyzeScaleFactor, &out.AutovacuumAnalyzeScaleFactor
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumCostLimit != nil {
		in, out := &in.AutovacuumVacuumCostLimit, &out.AutovacuumVacuumCostLimit
		*out = new(int64)
		**out = **in
	}
	if in.TempFileLimit != nil {
		in, out := &in.TempFileLimit, &out.TempFileLimit
		*out = new(int64)
		**out = **in
	}
	if in.MaxParallelWorkers != nil {
		in, out := &in.MaxParallelWorkers, &out.MaxParallelWorkers
		*out = new(int64)
		**out = **in
	}
	if in.MaxStandbyArchiveDelay != nil {
		in, out := &in.MaxStandbyArchiveDelay, &out.MaxStandbyArchiveDelay
		*out = new(int64)
		**out = **in
	}
	if in.WalWriterDelay != nil {
		in, out := &in.WalWriterDelay, &out.WalWriterDelay
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumAnalyzeThreshold != nil {
		in, out := &in.AutovacuumAnalyzeThreshold, &out.AutovacuumAnalyzeThreshold
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumNaptime != nil {
		in, out := &in.AutovacuumNaptime, &out.AutovacuumNaptime
		*out = new(int64)
		**out = **in
	}
	if in.DeadlockTimeout != nil {
		in, out := &in.DeadlockTimeout, &out.DeadlockTimeout
		*out = new(int64)
		**out = **in
	}
	if in.MaxLogicalReplicationWorkers != nil {
		in, out := &in.MaxLogicalReplicationWorkers, &out.MaxLogicalReplicationWorkers
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumMaxWorkers != nil {
		in, out := &in.AutovacuumMaxWorkers, &out.AutovacuumMaxWorkers
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumCostDelay != nil {
		in, out := &in.AutovacuumVacuumCostDelay, &out.AutovacuumVacuumCostDelay
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLSubUserConfig.
func (in *PostgreSQLSubUserConfig) DeepCopy() *PostgreSQLSubUserConfig {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLSubUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLUserconfig) DeepCopyInto(out *PostgreSQLUserconfig) {
	*out = *in
	if in.BackupMinute != nil {
		in, out := &in.BackupMinute, &out.BackupMinute
		*out = new(int64)
		**out = **in
	}
	if in.BackupHour != nil {
		in, out := &in.BackupHour, &out.BackupHour
		*out = new(int64)
		**out = **in
	}
	in.Pglookout.DeepCopyInto(&out.Pglookout)
	if in.SharedBuffersPercentage != nil {
		in, out := &in.SharedBuffersPercentage, &out.SharedBuffersPercentage
		*out = new(int64)
		**out = **in
	}
	in.Timescaledb.DeepCopyInto(&out.Timescaledb)
	if in.IPFilter != nil {
		in, out := &in.IPFilter, &out.IPFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Pgbouncer.DeepCopyInto(&out.Pgbouncer)
	in.Migration.DeepCopyInto(&out.Migration)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	if in.WorkMem != nil {
		in, out := &in.WorkMem, &out.WorkMem
		*out = new(int64)
		**out = **in
	}
	in.Pg.DeepCopyInto(&out.Pg)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLUserconfig.
func (in *PostgreSQLUserconfig) DeepCopy() *PostgreSQLUserconfig {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLUserconfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PrivateAccessUserConfig) DeepCopyInto(out *PrivateAccessUserConfig) {
	*out = *in
	if in.Pg != nil {
		in, out := &in.Pg, &out.Pg
		*out = new(bool)
		**out = **in
	}
	if in.Pgbouncer != nil {
		in, out := &in.Pgbouncer, &out.Pgbouncer
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PrivateAccessUserConfig.
func (in *PrivateAccessUserConfig) DeepCopy() *PrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(PrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	if in.BillingEmails != nil {
		in, out := &in.BillingEmails, &out.BillingEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPC) DeepCopyInto(out *ProjectVPC) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPC.
func (in *ProjectVPC) DeepCopy() *ProjectVPC {
	if in == nil {
		return nil
	}
	out := new(ProjectVPC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPC) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCList) DeepCopyInto(out *ProjectVPCList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectVPC, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCList.
func (in *ProjectVPCList) DeepCopy() *ProjectVPCList {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPCList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCSpec) DeepCopyInto(out *ProjectVPCSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCSpec.
func (in *ProjectVPCSpec) DeepCopy() *ProjectVPCSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCStatus) DeepCopyInto(out *ProjectVPCStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCStatus.
func (in *ProjectVPCStatus) DeepCopy() *ProjectVPCStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PublicAccessUserConfig) DeepCopyInto(out *PublicAccessUserConfig) {
	*out = *in
	if in.Pg != nil {
		in, out := &in.Pg, &out.Pg
		*out = new(bool)
		**out = **in
	}
	if in.Pgbouncer != nil {
		in, out := &in.Pgbouncer, &out.Pgbouncer
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PublicAccessUserConfig.
func (in *PublicAccessUserConfig) DeepCopy() *PublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(PublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Redis) DeepCopyInto(out *Redis) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Redis.
func (in *Redis) DeepCopy() *Redis {
	if in == nil {
		return nil
	}
	out := new(Redis)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Redis) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisList) DeepCopyInto(out *RedisList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Redis, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisList.
func (in *RedisList) DeepCopy() *RedisList {
	if in == nil {
		return nil
	}
	out := new(RedisList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RedisList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisMigration) DeepCopyInto(out *RedisMigration) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.Ssl != nil {
		in, out := &in.Ssl, &out.Ssl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisMigration.
func (in *RedisMigration) DeepCopy() *RedisMigration {
	if in == nil {
		return nil
	}
	out := new(RedisMigration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPrivateAccess) DeepCopyInto(out *RedisPrivateAccess) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPrivateAccess.
func (in *RedisPrivateAccess) DeepCopy() *RedisPrivateAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPrivateAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPrivatelinkAccess) DeepCopyInto(out *RedisPrivatelinkAccess) {
	*out = *in
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPrivatelinkAccess.
func (in *RedisPrivatelinkAccess) DeepCopy() *RedisPrivatelinkAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPrivatelinkAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPublicAccess) DeepCopyInto(out *RedisPublicAccess) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPublicAccess.
func (in *RedisPublicAccess) DeepCopy() *RedisPublicAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPublicAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSpec) DeepCopyInto(out *RedisSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSpec.
func (in *RedisSpec) DeepCopy() *RedisSpec {
	if in == nil {
		return nil
	}
	out := new(RedisSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisUserConfig) DeepCopyInto(out *RedisUserConfig) {
	*out = *in
	in.Migration.DeepCopyInto(&out.Migration)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PrivatelinkAccess.DeepCopyInto(&out.PrivatelinkAccess)
	if in.IPFilter != nil {
		in, out := &in.IPFilter, &out.IPFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.RedisLfuDecayTime != nil {
		in, out := &in.RedisLfuDecayTime, &out.RedisLfuDecayTime
		*out = new(int64)
		**out = **in
	}
	if in.RedisLfuLogFactor != nil {
		in, out := &in.RedisLfuLogFactor, &out.RedisLfuLogFactor
		*out = new(int64)
		**out = **in
	}
	if in.RedisPubsubClientOutputBufferLimit != nil {
		in, out := &in.RedisPubsubClientOutputBufferLimit, &out.RedisPubsubClientOutputBufferLimit
		*out = new(int64)
		**out = **in
	}
	if in.StaticIps != nil {
		in, out := &in.StaticIps, &out.StaticIps
		*out = new(bool)
		**out = **in
	}
	if in.RedisIoThreads != nil {
		in, out := &in.RedisIoThreads, &out.RedisIoThreads
		*out = new(int64)
		**out = **in
	}
	if in.RedisTimeout != nil {
		in, out := &in.RedisTimeout, &out.RedisTimeout
		*out = new(int64)
		**out = **in
	}
	if in.RedisNumberOfDatabases != nil {
		in, out := &in.RedisNumberOfDatabases, &out.RedisNumberOfDatabases
		*out = new(int64)
		**out = **in
	}
	if in.RedisSsl != nil {
		in, out := &in.RedisSsl, &out.RedisSsl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisUserConfig.
func (in *RedisUserConfig) DeepCopy() *RedisUserConfig {
	if in == nil {
		return nil
	}
	out := new(RedisUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceCommonSpec) DeepCopyInto(out *ServiceCommonSpec) {
	*out = *in
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceCommonSpec.
func (in *ServiceCommonSpec) DeepCopy() *ServiceCommonSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceCommonSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegration) DeepCopyInto(out *ServiceIntegration) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegration.
func (in *ServiceIntegration) DeepCopy() *ServiceIntegration {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegration) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationDatadogUserConfig) DeepCopyInto(out *ServiceIntegrationDatadogUserConfig) {
	*out = *in
	if in.ExcludeConsumerGroups != nil {
		in, out := &in.ExcludeConsumerGroups, &out.ExcludeConsumerGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExcludeTopics != nil {
		in, out := &in.ExcludeTopics, &out.ExcludeTopics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IncludeConsumerGroups != nil {
		in, out := &in.IncludeConsumerGroups, &out.IncludeConsumerGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IncludeTopics != nil {
		in, out := &in.IncludeTopics, &out.IncludeTopics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.KafkaCustomMetrics != nil {
		in, out := &in.KafkaCustomMetrics, &out.KafkaCustomMetrics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationDatadogUserConfig.
func (in *ServiceIntegrationDatadogUserConfig) DeepCopy() *ServiceIntegrationDatadogUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationDatadogUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaConnect) DeepCopyInto(out *ServiceIntegrationKafkaConnect) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaConnect.
func (in *ServiceIntegrationKafkaConnect) DeepCopy() *ServiceIntegrationKafkaConnect {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaConnectUserConfig) DeepCopyInto(out *ServiceIntegrationKafkaConnectUserConfig) {
	*out = *in
	out.KafkaConnect = in.KafkaConnect
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaConnectUserConfig.
func (in *ServiceIntegrationKafkaConnectUserConfig) DeepCopy() *ServiceIntegrationKafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaLogsUserConfig) DeepCopyInto(out *ServiceIntegrationKafkaLogsUserConfig) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaLogsUserConfig.
func (in *ServiceIntegrationKafkaLogsUserConfig) DeepCopy() *ServiceIntegrationKafkaLogsUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaLogsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationList) DeepCopyInto(out *ServiceIntegrationList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceIntegration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationList.
func (in *ServiceIntegrationList) DeepCopy() *ServiceIntegrationList {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegrationList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationMetricsUserConfig) DeepCopyInto(out *ServiceIntegrationMetricsUserConfig) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationMetricsUserConfig.
func (in *ServiceIntegrationMetricsUserConfig) DeepCopy() *ServiceIntegrationMetricsUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationMetricsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationSpec) DeepCopyInto(out *ServiceIntegrationSpec) {
	*out = *in
	in.DatadogUserConfig.DeepCopyInto(&out.DatadogUserConfig)
	out.KafkaConnectUserConfig = in.KafkaConnectUserConfig
	out.KafkaLogsUserConfig = in.KafkaLogsUserConfig
	out.MetricsUserConfig = in.MetricsUserConfig
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationSpec.
func (in *ServiceIntegrationSpec) DeepCopy() *ServiceIntegrationSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationStatus) DeepCopyInto(out *ServiceIntegrationStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationStatus.
func (in *ServiceIntegrationStatus) DeepCopy() *ServiceIntegrationStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceStatus) DeepCopyInto(out *ServiceStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceStatus.
func (in *ServiceStatus) DeepCopy() *ServiceStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUser) DeepCopyInto(out *ServiceUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUser.
func (in *ServiceUser) DeepCopy() *ServiceUser {
	if in == nil {
		return nil
	}
	out := new(ServiceUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserList) DeepCopyInto(out *ServiceUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserList.
func (in *ServiceUserList) DeepCopy() *ServiceUserList {
	if in == nil {
		return nil
	}
	out := new(ServiceUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserSpec) DeepCopyInto(out *ServiceUserSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserSpec.
func (in *ServiceUserSpec) DeepCopy() *ServiceUserSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserStatus) DeepCopyInto(out *ServiceUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserStatus.
func (in *ServiceUserStatus) DeepCopy() *ServiceUserStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TimescaledbUserConfig) DeepCopyInto(out *TimescaledbUserConfig) {
	*out = *in
	if in.MaxBackgroundWorkers != nil {
		in, out := &in.MaxBackgroundWorkers, &out.MaxBackgroundWorkers
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TimescaledbUserConfig.
func (in *TimescaledbUserConfig) DeepCopy() *TimescaledbUserConfig {
	if in == nil {
		return nil
	}
	out := new(TimescaledbUserConfig)
	in.DeepCopyInto(out)
	return out
}
